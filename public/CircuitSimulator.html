<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Circuit Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/13.0.2/math.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Single Circuit Tab -->
        <div id="single-tab" class="tab-content active">
            <div class="circuit-builder">
                <div class="gates-panel">
                    <h3>üéØ Quantum Gates</h3>
                    <button class="gate" draggable="true" data-gate="H">H</button>
                    <button class="gate" draggable="true" data-gate="X">X</button>
                    <button class="gate" draggable="true" data-gate="Y">Y</button>
                    <button class="gate" draggable="true" data-gate="Z">Z</button>
                    <button class="gate" draggable="true" data-gate="SX">‚àöX</button>
                    <button class="gate" draggable="true" data-gate="SY">‚àöY</button>
                    <button class="gate" draggable="true" data-gate="SZ">‚àöZ</button>
                    <button class="gate" draggable="true" data-gate="RX90">RX(90¬∞)</button>
                    <button class="gate" draggable="true" data-gate="RY90">RY(90¬∞)</button>
                    <button class="gate" draggable="true" data-gate="RZ90">RZ(90¬∞)</button>
                </div>

                <div class="circuit-area">
                    <div class="qubit-controls">
                        <input type="number" id="numQubits" value="3" min="1" max="8" placeholder="Number of qubits">
                        <input type="number" id="numSteps" value="5" min="1" max="20" placeholder="Number of steps">
                        <button class="btn btn-primary" onclick="createCircuit()">Create Circuit</button>
                        <button class="btn btn-success" onclick="runSimulation()">Run Simulation</button>
                        <button class="btn btn-warning" onclick="clearCircuit()">Clear</button>
                    </div>
                    <div id="circuit" class="circuit"></div>
                </div>
            </div>

            <div class="results-panel">
                <h3>üìä Simulation Results</h3>
                <div class="chart-container">
                    <canvas id="probabilityChart"></canvas>
                </div>
                <div id="stateVector" class="state-vector"></div>
            </div>
        </div>

        <!-- Quantum Network Tab -->
        <div id="network-tab" class="tab-content">
            <div class="entanglement-controls">
                <h4>üîó Entanglement Configuration</h4>
                <div id="entanglementConfig"></div>
                <button class="btn btn-primary" onclick="generateNetworkCircuit()">Generate Network Circuit</button>
            </div>

            <div class="network-panel">
                <div class="node-panel">
                    <h3>üñ•Ô∏è Node 1 Circuit</h3>
                    <div class="circuit-builder">
                        <div class="gates-panel">
                            <h4>Gates</h4>
                            <button class="gate" draggable="true" data-gate="H">H</button>
                            <button class="gate" draggable="true" data-gate="X">X</button>
                            <button class="gate" draggable="true" data-gate="Y">Y</button>
                            <button class="gate" draggable="true" data-gate="Z">Z</button>
                            <button class="gate" draggable="true" data-gate="SX">‚àöX</button>
                            <button class="gate" draggable="true" data-gate="SY">‚àöY</button>
                            <button class="gate" draggable="true" data-gate="SZ">‚àöZ</button>
                            <button class="gate" draggable="true" data-gate="RX90">RX(90¬∞)</button>
                            <button class="gate" draggable="true" data-gate="RY90">RY(90¬∞)</button>
                            <button class="gate" draggable="true" data-gate="RZ90">RZ(90¬∞)</button>
                        </div>
                        <div class="circuit-area">
                            <div class="qubit-controls">
                                <input type="number" id="node1Qubits" value="2" min="1" max="4" placeholder="Qubits">
                                <input type="number" id="node1Steps" value="3" min="1" max="10" placeholder="Steps">
                                <button class="btn btn-primary" onclick="createNodeCircuit(1)">Create Node 1</button>
                            </div>
                            <div id="node1Circuit" class="circuit"></div>
                        </div>
                    </div>
                </div>

                <div class="node-panel">
                    <h3>üñ•Ô∏è Node 2 Circuit</h3>
                    <div class="circuit-builder">
                        <div class="gates-panel">
                            <h4>Gates</h4>
                            <button class="gate" draggable="true" data-gate="H">H</button>
                            <button class="gate" draggable="true" data-gate="X">X</button>
                            <button class="gate" draggable="true" data-gate="Y">Y</button>
                            <button class="gate" draggable="true" data-gate="Z">Z</button>
                            <button class="gate" draggable="true" data-gate="SX">‚àöX</button>
                            <button class="gate" draggable="true" data-gate="SY">‚àöY</button>
                            <button class="gate" draggable="true" data-gate="SZ">‚àöZ</button>
                            <button class="gate" draggable="true" data-gate="RX90">RX(90¬∞)</button>
                            <button class="gate" draggable="true" data-gate="RY90">RY(90¬∞)</button>
                            <button class="gate" draggable="true" data-gate="RZ90">RZ(90¬∞)</button>
                        </div>
                        <div class="circuit-area">
                            <div class="qubit-controls">
                                <input type="number" id="node2Qubits" value="2" min="1" max="4" placeholder="Qubits">
                                <input type="number" id="node2Steps" value="3" min="1" max="10" placeholder="Steps">
                                <button class="btn btn-primary" onclick="createNodeCircuit(2)">Create Node 2</button>
                            </div>
                            <div id="node2Circuit" class="circuit"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="network-result">
                <h3>üåê Combined Network Circuit</h3>
                <button class="btn btn-success" onclick="runNetworkSimulation()">Run Network Simulation</button>
                <div id="networkCircuit" class="circuit"></div>
                <div class="chart-container">
                    <canvas id="networkProbabilityChart"></canvas>
                </div>
                <div id="networkStateVector" class="state-vector"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        var defaultDecimalPrecision = 3;
        var precisionForApproximateComparison = 0.01;
        var usingTextbookConvention = false;
        var simulator = null;

        // Utility classes
        function Util() {}

        Util.assert = function(condition, message) {
            if (!condition) {
                console.log("ASSERTION ERROR: " + message);
                console.trace();
            }
        };

        Util.approximatelyEqual = function(a, b, tolerance) {
            tolerance = tolerance || precisionForApproximateComparison;
            var delta = Math.abs(a - b);
            return delta <= tolerance;
        };

        function StringUtil() {}

        StringUtil.numToString = function(x, decimalPrecision) {
            decimalPrecision = decimalPrecision || defaultDecimalPrecision;
            var s1 = x.toString();
            var s2 = x.toFixed(decimalPrecision);
            return s1.length < s2.length ? s1 : s2;
        };

        StringUtil.repeatString = function(s, n) {
            var r = "";
            for (var j = 0; j < n; j++) {
                r += s;
            }
            return r;
        };

        StringUtil.intToBinaryString = function(i, desiredWidth) {
            var binaryString = i.toString(2);
            return StringUtil.repeatString('0', desiredWidth - binaryString.length) + binaryString;
        };

        // Complex number class
        function Complex(re, im) {
            this._r = re || 0;
            this._i = im || 0;
        }

        Complex.prototype.toString = function(decimalPrecision) {
            if (this._r === 0) {
                if (this._i === 0) {
                    return "0";
                } else {
                    return StringUtil.numToString(this._i, decimalPrecision) + "i";
                }
            } else {
                if (this._i === 0) {
                    return StringUtil.numToString(this._r, decimalPrecision);
                } else {
                    var rs = StringUtil.numToString(this._r, decimalPrecision);
                    var is = StringUtil.numToString(this._i, decimalPrecision) + "i";
                    return is[0] === '-' ? (rs + is) : (rs + "+" + is);
                }
            }
        };

        Complex.prototype.copy = function() {
            return new Complex(this._r, this._i);
        };

        Complex.prototype.conjugate = function() {
            return new Complex(this._r, -this._i);
        };

        Complex.prototype.mag = function() {
            return Math.sqrt(this._r * this._r + this._i * this._i);
        };

        Complex.prototype.magSquared = function() {
            return this._r * this._r + this._i * this._i;
        };

        Complex.sum = function(c1, c2) {
            return new Complex(c1._r + c2._r, c1._i + c2._i);
        };

        Complex.mult = function(c1, c2) {
            if (c1 instanceof Complex) {
                if (c2 instanceof Complex) {
                    return new Complex(c1._r * c2._r - c1._i * c2._i, c1._r * c2._i + c1._i * c2._r);
                }
                return new Complex(c1._r * c2, c1._i * c2);
            } else if (c2 instanceof Complex) {
                return new Complex(c1 * c2._r, c1 * c2._i);
            }
            return c1 * c2;
        };

        Complex.i = new Complex(0, 1);

        // Matrix class
        function CMatrix(numRows, numCols) {
            this._rows = numRows;
            this._cols = numCols;
            this._m = new Float32Array(numRows * numCols * 2);
        }

        CMatrix.prototype.get = function(row, col) {
            var j = (row * this._cols + col) * 2;
            return new Complex(this._m[j], this._m[j + 1]);
        };

        CMatrix.prototype.set = function(row, col, value) {
            var j = (row * this._cols + col) * 2;
            if (typeof value === 'number') {
                this._m[j] = value;
                this._m[j + 1] = 0;
            } else if (value instanceof Complex) {
                this._m[j] = value._r;
                this._m[j + 1] = value._i;
            }
        };

        CMatrix.prototype.copy = function() {
            var M = new CMatrix(this._rows, this._cols);
            for (var i = 0; i < this._m.length; i++) {
                M._m[i] = this._m[i];
            }
            return M;
        };

        CMatrix.mult = function(a, b) {
            if (!(a instanceof CMatrix)) {
                var tmp = b;
                b = a;
                a = tmp;
            }

            if (typeof b === 'number') {
                var M = a.copy();
                for (var j = M._m.length - 1; j >= 0; j--) {
                    M._m[j] *= b;
                }
                return M;
            } else if (b instanceof CMatrix) {
                var M = new CMatrix(a._rows, b._cols);
                for (var r = 0; r < M._rows; r++) {
                    for (var c = 0; c < M._cols; c++) {
                        var dotProduct = new Complex();
                        for (var k = 0; k < a._cols; k++) {
                            dotProduct = Complex.sum(dotProduct, Complex.mult(a.get(r, k), b.get(k, c)));
                        }
                        M.set(r, c, dotProduct);
                    }
                }
                return M;
            }
        };

        CMatrix.create = function(arrayOfArrays) {
            var numRows = arrayOfArrays.length;
            var numCols = arrayOfArrays[0].length;
            var M = new CMatrix(numRows, numCols);
            for (var j = 0; j < numRows; j++) {
                for (var k = 0; k < numCols; k++) {
                    M.set(j, k, arrayOfArrays[j][k]);
                }
            }
            return M;
        };

        CMatrix.createColVector = function(array) {
            return CMatrix.create(array.map(function(x) { return [x]; }));
        };

        CMatrix.identity = function(numRows) {
            var M = new CMatrix(numRows, numRows);
            for (var k = 0; k < numRows; k++) {
                M.set(k, k, 1);
            }
            return M;
        };

        // Simulation class
        function Sim() {}

        Sim.qubitWiseMultiply = function(U, i_w, n, stateVector, listOfControlBits) {
            listOfControlBits = listOfControlBits || [];
            var sizeOfStateVector = 1 << n;
            
            var inclusionMask = 0;
            var desiredValueMask = 0;
            for (var i = 0; i < listOfControlBits.length; i++) {
                var wireIndex = listOfControlBits[i][0];
                var flag = listOfControlBits[i][1];
                var bit = 1 << wireIndex;
                inclusionMask |= bit;
                if (flag) {
                    desiredValueMask |= bit;
                }
            }

            var tempVector = new CMatrix(2, 1);
            var sizeOfHalfBlock = 1 << i_w;
            var sizeOfBlock = sizeOfHalfBlock << 1;
            var result = stateVector.copy();
            
            for (var indexOfStartOfBlock = 0; indexOfStartOfBlock < sizeOfStateVector; indexOfStartOfBlock += sizeOfBlock) {
                for (var offsetWithinBlock = 0; offsetWithinBlock < sizeOfHalfBlock; offsetWithinBlock++) {
                    var i1 = indexOfStartOfBlock | offsetWithinBlock;
                    if ((i1 & inclusionMask) !== desiredValueMask) {
                        continue;
                    }

                    var i2 = i1 | sizeOfHalfBlock;

                    tempVector.set(0, 0, stateVector.get(i1, 0));
                    tempVector.set(1, 0, stateVector.get(i2, 0));

                    var transformedVector = CMatrix.mult(U, tempVector);

                    result.set(i1, 0, transformedVector.get(0, 0));
                    result.set(i2, 0, transformedVector.get(1, 0));
                }
            }
            return result;
        };

        Sim.init = function() {
            Sim.ketZero = CMatrix.createColVector([1, 0]);
            Sim.ketOne = CMatrix.createColVector([0, 1]);
            Sim.ketPlus = CMatrix.createColVector([Math.SQRT1_2, Math.SQRT1_2]);
            Sim.ketMinus = CMatrix.createColVector([Math.SQRT1_2, -Math.SQRT1_2]);

            Sim.I = CMatrix.identity(2);
            Sim.H = CMatrix.mult(CMatrix.create([[1, 1], [1, -1]]), Math.SQRT1_2);
            Sim.X = CMatrix.create([[0, 1], [1, 0]]);
            Sim.Y = CMatrix.create([[new Complex(0, 0), new Complex(0, -1)], [new Complex(0, 1), new Complex(0, 0)]]);
            Sim.Z = CMatrix.create([[1, 0], [0, -1]]);

            Sim.SX = CMatrix.mult(
                CMatrix.create([[new Complex(1, 1), new Complex(1, -1)], [new Complex(1, -1), new Complex(1, 1)]]),
                0.5
            );
            Sim.SY = CMatrix.mult(
                CMatrix.create([[new Complex(1, 1), new Complex(-1, -1)], [new Complex(1, 1), new Complex(1, 1)]]),
                0.5
            );
            Sim.SZ = CMatrix.create(
                [[new Complex(1, 0), new Complex(0, 0)], [new Complex(0, 0), new Complex(0, 1)]]
            );

            Sim.RX_90deg = CMatrix.create([[new Complex(Math.SQRT1_2, 0), new Complex(0, -Math.SQRT1_2)], [new Complex(0, -Math.SQRT1_2), new Complex(Math.SQRT1_2, 0)]]);
            Sim.RY_90deg = CMatrix.create([[new Complex(Math.SQRT1_2, 0), new Complex(-Math.SQRT1_2, 0)], [new Complex(Math.SQRT1_2, 0), new Complex(Math.SQRT1_2, 0)]]);
            Sim.RZ_90deg = CMatrix.create([[new Complex(Math.SQRT1_2, -Math.SQRT1_2), new Complex(0, 0)], [new Complex(0, 0), new Complex(Math.SQRT1_2, Math.SQRT1_2)]]);
        };

        // Quantum Simulator class
        function QuantumSimulator() {
            this.circuit = [];
            this.numQubits = 3;
            this.numSteps = 5;
            this.nodeCircuits = { 1: [], 2: [] };
            this.entanglements = [];
            this.networkCircuit = [];
        }

        QuantumSimulator.prototype.setupDragAndDrop = function() {
            var gates = document.querySelectorAll('.gate');
            for (var i = 0; i < gates.length; i++) {
                gates[i].addEventListener('dragstart', function(e) {
                    var gateType = e.target.getAttribute('data-gate');
                    e.dataTransfer.setData('text/plain', gateType);
                    e.dataTransfer.effectAllowed = 'copy';
                });
            }
        };

        QuantumSimulator.prototype.createCircuit = function() {
            try {
                var numQubitsInput = document.getElementById('numQubits');
                var numStepsInput = document.getElementById('numSteps');
                
                if (!numQubitsInput || !numStepsInput) {
                    console.error('Input elements not found');
                    return;
                }
                
                this.numQubits = parseInt(numQubitsInput.value) || 3;
                this.numSteps = parseInt(numStepsInput.value) || 5;
                
                if (this.numQubits < 1 || this.numQubits > 8) {
                    this.showError('Number of qubits must be between 1 and 8');
                    return;
                }

                this.circuit = [];
                for (var i = 0; i < this.numQubits; i++) {
                    this.circuit[i] = [];
                    for (var j = 0; j < this.numSteps; j++) {
                        this.circuit[i][j] = null;
                    }
                }
                
                this.renderCircuit('circuit', this.circuit, this.numQubits, this.numSteps);
                
                var self = this;
                setTimeout(function() {
                    self.setupDragAndDrop();
                }, 100);
                
            } catch (error) {
                console.error('Error in createCircuit:', error);
                this.showError('Failed to create circuit: ' + error.message);
            }
        };

        QuantumSimulator.prototype.createNodeCircuit = function(nodeNum) {
            var qubitsId = 'node' + nodeNum + 'Qubits';
            var stepsId = 'node' + nodeNum + 'Steps';
            var circuitId = 'node' + nodeNum + 'Circuit';
            
            var numQubits = parseInt(document.getElementById(qubitsId).value) || 2;
            var numSteps = parseInt(document.getElementById(stepsId).value) || 3;
            
            if (numQubits < 1 || numQubits > 4) {
                this.showError('Node ' + nodeNum + ': Number of qubits must be between 1 and 4');
                return;
            }

            this.nodeCircuits[nodeNum] = [];
            for (var i = 0; i < numQubits; i++) {
                this.nodeCircuits[nodeNum][i] = [];
                for (var j = 0; j < numSteps; j++) {
                    this.nodeCircuits[nodeNum][i][j] = null;
                }
            }
            
            this.renderCircuit(circuitId, this.nodeCircuits[nodeNum], numQubits, numSteps, nodeNum);
            this.updateEntanglementControls();
            
            var self = this;
            setTimeout(function() {
                self.setupDragAndDrop();
            }, 100);
        };

        QuantumSimulator.prototype.renderCircuit = function(containerId, circuit, numQubits, numSteps, nodeNum) {
            var container = document.getElementById(containerId);
            if (!container) {
                console.error('Container ' + containerId + ' not found');
                return;
            }
            container.innerHTML = '';

            for (var qubit = 0; qubit < numQubits; qubit++) {
                var qubitLine = document.createElement('div');
                qubitLine.className = 'qubit-line';

                var label = document.createElement('div');
                label.className = 'qubit-label';
                label.textContent = nodeNum ? 'N' + nodeNum + 'Q' + qubit : 'Q' + qubit;
                qubitLine.appendChild(label);

                var wire = document.createElement('div');
                wire.className = 'qubit-wire';
                
                for (var step = 0; step < numSteps; step++) {
                    var slot = document.createElement('div');
                    slot.className = 'gate-slot';
                    slot.setAttribute('data-qubit', qubit);
                    slot.setAttribute('data-step', step);
                    slot.setAttribute('data-node', nodeNum || 'single');

                    if (circuit[qubit] && circuit[qubit][step]) {
                        slot.textContent = circuit[qubit][step];
                        slot.className += ' occupied';
                    }

                    this.setupDropZone(slot, circuit);
                    wire.appendChild(slot);
                }

                qubitLine.appendChild(wire);
                container.appendChild(qubitLine);
            }
        };

        QuantumSimulator.prototype.setupDropZone = function(slot, circuit) {
            slot.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                slot.classList.add('drag-over');
            });

            slot.addEventListener('dragleave', function(e) {
                if (!slot.contains(e.relatedTarget)) {
                    slot.classList.remove('drag-over');
                }
            });

            slot.addEventListener('drop', function(e) {
                e.preventDefault();
                slot.classList.remove('drag-over');
                
                var gateType = e.dataTransfer.getData('text/plain');
                var qubit = parseInt(slot.getAttribute('data-qubit'));
                var step = parseInt(slot.getAttribute('data-step'));
                
                if (gateType && circuit[qubit]) {
                    circuit[qubit][step] = gateType;
                    slot.textContent = gateType;
                    slot.className = 'gate-slot occupied';
                }
            });

            slot.addEventListener('click', function() {
                if (slot.classList.contains('occupied')) {
                    var qubit = parseInt(slot.getAttribute('data-qubit'));
                    var step = parseInt(slot.getAttribute('data-step'));
                    if (circuit[qubit]) {
                        circuit[qubit][step] = null;
                        slot.textContent = '';
                        slot.className = 'gate-slot';
                    }
                }
            });
        };

        QuantumSimulator.prototype.updateEntanglementControls = function() {
            var container = document.getElementById('entanglementConfig');
            if (!container) return;
            
            container.innerHTML = '';

            var node1Qubits = this.nodeCircuits[1].length || 0;
            var node2Qubits = this.nodeCircuits[2].length || 0;

            if (node1Qubits === 0 || node2Qubits === 0) {
                container.innerHTML = '<p>Create circuits for both nodes first</p>';
                return;
            }

            container.innerHTML = '<p>Select qubit pairs to entangle:</p>';
            
            for (var i = 0; i < Math.min(node1Qubits, node2Qubits); i++) {
                var entangleDiv = document.createElement('div');
                entangleDiv.innerHTML = 
                    '<label class="qubit-checkbox">' +
                    '<input type="checkbox" data-node1-qubit="' + i + '" data-node2-qubit="' + i + '">' +
                    'Entangle N1Q' + i + ' ‚Üî N2Q' + i +
                    '</label>';
                container.appendChild(entangleDiv);
            }
        };

        QuantumSimulator.prototype.generateNetworkCircuit = function() {
            var node1Qubits = this.nodeCircuits[1].length || 0;
            var node2Qubits = this.nodeCircuits[2].length || 0;
            
            if (node1Qubits === 0 || node2Qubits === 0) {
                this.showError('Create circuits for both nodes first');
                return;
            }

            this.entanglements = [];
            var checkboxes = document.querySelectorAll('#entanglementConfig input[type="checkbox"]:checked');
            for (var i = 0; i < checkboxes.length; i++) {
                this.entanglements.push({
                    node1Qubit: parseInt(checkboxes[i].getAttribute('data-node1-qubit')),
                    node2Qubit: parseInt(checkboxes[i].getAttribute('data-node2-qubit'))
                });
            }

            var totalQubits = node1Qubits + node2Qubits;
            var maxSteps = Math.max(
                this.nodeCircuits[1][0] ? this.nodeCircuits[1][0].length : 0,
                this.nodeCircuits[2][0] ? this.nodeCircuits[2][0].length : 0
            ) + 3;

            this.networkCircuit = [];
            for (var i = 0; i < totalQubits; i++) {
                this.networkCircuit[i] = [];
                for (var j = 0; j < maxSteps; j++) {
                    this.networkCircuit[i][j] = null;
                }
            }

            // Add entanglement gates
            var entanglementStep = 0;
            for (var i = 0; i < this.entanglements.length; i++) {
                var ent = this.entanglements[i];
                var node1QubitIndex = ent.node1Qubit;
                var node2QubitIndex = node1Qubits + ent.node2Qubit;
                
                this.networkCircuit[node1QubitIndex][entanglementStep] = 'H';
                this.networkCircuit[node1QubitIndex][entanglementStep + 1] = 'CNOT_CTRL';
                this.networkCircuit[node2QubitIndex][entanglementStep + 1] = 'CNOT_TGT';
            }

            var nodeStepOffset = 2;
            
            // Apply node 1 circuit
            for (var q = 0; q < node1Qubits; q++) {
                for (var s = 0; s < this.nodeCircuits[1][q].length; s++) {
                    if (this.nodeCircuits[1][q][s]) {
                        this.networkCircuit[q][s + nodeStepOffset] = this.nodeCircuits[1][q][s];
                    }
                }
            }

            // Apply node 2 circuit (reversed)
            for (var q = 0; q < node2Qubits; q++) {
                var reversedQubitIndex = node1Qubits + (node2Qubits - 1 - q);
                for (var s = 0; s < this.nodeCircuits[2][q].length; s++) {
                    if (this.nodeCircuits[2][q][s]) {
                        this.networkCircuit[reversedQubitIndex][s + nodeStepOffset] = this.nodeCircuits[2][q][s];
                    }
                }
            }

            // Add final measurement Hadamards
            var finalStep = maxSteps - 1;
            for (var i = 0; i < this.entanglements.length; i++) {
                var ent = this.entanglements[i];
                var node1QubitIndex = ent.node1Qubit;
                var node2QubitIndex = node1Qubits + ent.node2Qubit;
                this.networkCircuit[node1QubitIndex][finalStep] = 'H';
                this.networkCircuit[node2QubitIndex][finalStep] = 'H';
            }

            this.renderCircuit('networkCircuit', this.networkCircuit, totalQubits, maxSteps, 'network');
            this.showSuccess('Network circuit generated successfully!');
        };

        QuantumSimulator.prototype.runSimulation = function() {
            if (this.circuit.length === 0) {
                this.showError('Create a circuit first');
                return;
            }

            try {
                console.log('Starting simulation...');
                var result = this.simulateCircuit(this.circuit, this.numQubits);
                console.log('Simulation completed, displaying results...');
                this.displayResults(result, 'probabilityChart', 'stateVector');
                this.showSuccess('Simulation completed successfully!');
            } catch (error) {
                console.error('Simulation error:', error);
                this.showError('Simulation failed: ' + error.message);
                
                // Try to show just the state vector without chart
                try {
                    var result = this.simulateCircuit(this.circuit, this.numQubits);
                    this.updateStateVector(result.stateVector, 'stateVector');
                    this.showSuccess('Simulation completed (chart display failed, but state vector shown)');
                } catch (fallbackError) {
                    console.error('Fallback simulation also failed:', fallbackError);
                }
            }
        };

        QuantumSimulator.prototype.runNetworkSimulation = function() {
            if (this.networkCircuit.length === 0) {
                this.showError('Generate network circuit first');
                return;
            }

            try {
                console.log('Starting network simulation...');
                var totalQubits = this.networkCircuit.length;
                var result = this.simulateCircuit(this.networkCircuit, totalQubits);
                console.log('Network simulation completed, displaying results...');
                this.displayResults(result, 'networkProbabilityChart', 'networkStateVector');
                this.showSuccess('Network simulation completed successfully!');
            } catch (error) {
                console.error('Network simulation error:', error);
                this.showError('Network simulation failed: ' + error.message);
                
                // Try to show just the state vector without chart
                try {
                    var totalQubits = this.networkCircuit.length;
                    var result = this.simulateCircuit(this.networkCircuit, totalQubits);
                    this.updateStateVector(result.stateVector, 'networkStateVector');
                    this.showSuccess('Network simulation completed (chart display failed, but state vector shown)');
                } catch (fallbackError) {
                    console.error('Fallback network simulation also failed:', fallbackError);
                }
            }
        };

        QuantumSimulator.prototype.simulateCircuit = function(circuit, numQubits) {
            var stateVector = CMatrix.createColVector(new Array(1 << numQubits).fill(0));
            stateVector.set(0, 0, 1);

            var numSteps = circuit[0].length;

            for (var step = 0; step < numSteps; step++) {
                // Handle CNOT gates
                var cnotPairs = [];
                for (var qubit = 0; qubit < numQubits; qubit++) {
                    if (circuit[qubit][step] === 'CNOT_CTRL' || circuit[qubit][step] === 'CNOT_CONTROL') {
                        for (var target = 0; target < numQubits; target++) {
                            if (circuit[target][step] === 'CNOT_TGT' || circuit[target][step] === 'CNOT_TARGET') {
                                cnotPairs.push([qubit, target]);
                                break;
                            }
                        }
                    }
                }

                for (var i = 0; i < cnotPairs.length; i++) {
                    var control = cnotPairs[i][0];
                    var target = cnotPairs[i][1];
                    stateVector = Sim.qubitWiseMultiply(Sim.X, target, numQubits, stateVector, [[control, true]]);
                }

                // Handle single-qubit gates
                for (var qubit = 0; qubit < numQubits; qubit++) {
                    var gate = circuit[qubit][step];
                    if (gate && gate.indexOf('CNOT') === -1) {
                        var gateMatrix = this.getGateMatrix(gate);
                        if (gateMatrix) {
                            stateVector = Sim.qubitWiseMultiply(gateMatrix, qubit, numQubits, stateVector);
                        }
                    }
                }
            }

            var probabilities = [];
            for (var i = 0; i < stateVector._rows; i++) {
                var amplitude = stateVector.get(i, 0);
                probabilities.push(amplitude.magSquared());
            }

            return { stateVector: stateVector, probabilities: probabilities };
        };

        QuantumSimulator.prototype.getGateMatrix = function(gateName) {
            var gates = {
                'H': Sim.H,
                'X': Sim.X,
                'Y': Sim.Y,
                'Z': Sim.Z,
                'SX': Sim.SX,
                'SY': Sim.SY,
                'SZ': Sim.SZ,
                'RX90': Sim.RX_90deg,
                'RY90': Sim.RY_90deg,
                'RZ90': Sim.RZ_90deg
            };
            return gates[gateName] || null;
        };

        QuantumSimulator.prototype.displayResults = function(result, chartId, vectorId) {
            this.updateProbabilityChart(result.probabilities, chartId);
            this.updateStateVector(result.stateVector, vectorId);
        };

        QuantumSimulator.prototype.updateProbabilityChart = function(probabilities, chartId) {
            var ctx = document.getElementById(chartId);
            if (!ctx) return;

            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                console.warn('Chart.js not available, displaying text results instead');
                this.displayTextChart(probabilities, chartId);
                return;
            }

            if (window[chartId + '_instance']) {
                window[chartId + '_instance'].destroy();
            }

            var numQubits = Math.log2(probabilities.length);
            var labels = [];
            var backgroundColors = [];
            var borderColors = [];
            
            for (var i = 0; i < probabilities.length; i++) {
                labels.push('|' + StringUtil.intToBinaryString(i, numQubits) + '‚ü©');
                if (probabilities[i] > 0.01) {
                    backgroundColors.push('rgba(54, 162, 235, 0.8)');
                    borderColors.push('rgba(54, 162, 235, 1)');
                } else {
                    backgroundColors.push('rgba(201, 203, 207, 0.3)');
                    borderColors.push('rgba(201, 203, 207, 0.8)');
                }
            }

            try {
                window[chartId + '_instance'] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Probability',
                            data: probabilities,
                            backgroundColor: backgroundColors,
                            borderColor: borderColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 1,
                                title: {
                                    display: true,
                                    text: 'Probability'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Quantum States'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Quantum State Probabilities'
                            },
                            legend: {
                                display: false
                            }
                        }
                    }
                });
            } catch (error) {
                console.warn('Chart.js error, falling back to text display:', error);
                this.displayTextChart(probabilities, chartId);
            }
        };

        QuantumSimulator.prototype.displayTextChart = function(probabilities, chartId) {
            var container = document.getElementById(chartId);
            if (!container) return;
            
            var numQubits = Math.log2(probabilities.length);
            var html = '<div style="background: white; padding: 20px; border-radius: 8px; font-family: monospace;">';
            html += '<h4>Quantum State Probabilities:</h4>';
            html += '<div style="max-height: 300px; overflow-y: auto;">';
            
            for (var i = 0; i < probabilities.length; i++) {
                if (probabilities[i] > 0.001) {
                    var binaryState = StringUtil.intToBinaryString(i, numQubits);
                    var barWidth = Math.max(2, probabilities[i] * 400); // Scale bar width
                    var color = probabilities[i] > 0.01 ? '#36a2eb' : '#c9cbcf';
                    
                    html += '<div style="margin: 5px 0; display: flex; align-items: center;">';
                    html += '<span style="width: 80px; display: inline-block;">|' + binaryState + '‚ü©:</span>';
                    html += '<div style="background: ' + color + '; height: 20px; width: ' + barWidth + 'px; margin-right: 10px;"></div>';
                    html += '<span>' + probabilities[i].toFixed(4) + '</span>';
                    html += '</div>';
                }
            }
            
            html += '</div></div>';
            container.innerHTML = html;
        };

        QuantumSimulator.prototype.updateStateVector = function(stateVector, containerId) {
            var container = document.getElementById(containerId);
            if (!container) return;

            var numQubits = Math.log2(stateVector._rows);
            var html = '<h4>State Vector:</h4><div style="font-family: monospace; line-height: 1.6;">';
            
            for (var i = 0; i < stateVector._rows; i++) {
                var amplitude = stateVector.get(i, 0);
                var probability = amplitude.magSquared();
                var binaryState = StringUtil.intToBinaryString(i, numQubits);
                
                if (probability > 0.001) {
                    html += '|' + binaryState + '‚ü©: ' + amplitude.toString() + ' (P = ' + probability.toFixed(4) + ')<br>';
                }
            }
            
            html += '</div>';
            container.innerHTML = html;
        };

        QuantumSimulator.prototype.clearCircuit = function() {
            this.circuit = [];
            var circuitContainer = document.getElementById('circuit');
            if (circuitContainer) {
                circuitContainer.innerHTML = '';
            }
            this.clearResults();
        };

        QuantumSimulator.prototype.clearResults = function() {
            var stateVectorContainer = document.getElementById('stateVector');
            if (stateVectorContainer) {
                stateVectorContainer.innerHTML = '';
            }
            if (window.probabilityChart_instance) {
                window.probabilityChart_instance.destroy();
            }
        };

        QuantumSimulator.prototype.showError = function(message) {
            this.showMessage(message, 'error');
        };

        QuantumSimulator.prototype.showSuccess = function(message) {
            this.showMessage(message, 'success');
        };

        QuantumSimulator.prototype.showMessage = function(message, type) {
            var existingMessages = document.querySelectorAll('.error, .success');
            for (var i = 0; i < existingMessages.length; i++) {
                existingMessages[i].remove();
            }
            
            var messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            
            var activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                activeTab.insertBefore(messageDiv, activeTab.firstChild);
                setTimeout(function() {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, 5000);
            }
        };

        // Global functions for UI
        function showTab(tabName) {
            var tabs = document.querySelectorAll('.tab');
            for (var i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove('active');
            }
            
            var contents = document.querySelectorAll('.tab-content');
            for (var i = 0; i < contents.length; i++) {
                contents[i].classList.remove('active');
            }
            
            var targetTab = document.querySelector('[onclick="showTab(\'' + tabName + '\')"]');
            var targetContent = document.getElementById(tabName + '-tab');
            
            if (targetTab) targetTab.classList.add('active');
            if (targetContent) targetContent.classList.add('active');
        }

        function createCircuit() {
            if (simulator) {
                simulator.createCircuit();
            }
        }

        function createNodeCircuit(nodeNum) {
            if (simulator) {
                simulator.createNodeCircuit(nodeNum);
            }
        }

        function runSimulation() {
            if (simulator) {
                simulator.runSimulation();
            }
        }

        function runNetworkSimulation() {
            if (simulator) {
                simulator.runNetworkSimulation();
            }
        }

        function generateNetworkCircuit() {
            if (simulator) {
                simulator.generateNetworkCircuit();
            }
        }

        function clearCircuit() {
            if (simulator) {
                simulator.clearCircuit();
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            try {
                console.log('Initializing Quantum Simulator...');
                
                // Check for required libraries
                if (typeof math === 'undefined') {
                    throw new Error('Math.js library not loaded');
                }
                
                // Chart.js is optional - we have a fallback
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not available - using text-based charts');
                }
                
                // Initialize Sim first
                Sim.init();
                console.log('Sim initialized');
                
                // Create simulator instance
                simulator = new QuantumSimulator();
                console.log('Simulator created successfully');
                
                // Create initial circuit
                simulator.createCircuit();
                console.log('Initial circuit created');
                
                // Setup initial drag and drop
                setTimeout(function() {
                    simulator.setupDragAndDrop();
                    console.log('Drag and drop setup complete');
                }, 200);
                
                // Show success message
                setTimeout(function() {
                    if (simulator) {
                        simulator.showSuccess('Quantum Simulator initialized successfully! Drag gates to build circuits.');
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Initialization error:', error);
                var errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'padding: 20px; text-align: center; color: red; background: #fff; margin: 20px; border-radius: 10px; border: 2px solid #dc3545;';
                errorDiv.innerHTML = 
                    '<h2>üö® Error Loading Simulator</h2>' +
                    '<p>There was an error initializing the quantum simulator.</p>' +
                    '<p><strong>Error:</strong> ' + error.message + '</p>' +
                    '<p><strong>Troubleshooting:</strong></p>' +
                    '<ul style="text-align: left; display: inline-block;">' +
                    '<li>Make sure you have an internet connection for loading libraries</li>' +
                    '<li>Try refreshing the page</li>' +
                    '<li>Check browser console for more details</li>' +
                    '</ul>' +
                    '<button onclick="location.reload()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">üîÑ Reload Page</button>';
                document.body.appendChild(errorDiv);
            }
        });
    </script>
</body>
</html>